# Лабораторная работа № 3  
Объектно‑ориентированное программирование в Java  
*(конструкторы, инкапсуляция, наследование, полиморфизм)*

## 1. Цель изучения темы

После изучения данного материала будем уметь:
- создавать собственные классы;
- использовать конструкторы;
- применять инкапсуляцию и модификаторы доступа;
- реализовывать наследование;
- переопределять методы;
- понимать и применять полиморфизм;
- проектировать простую объектную модель задачи;
- читать и писать код, оформленный в соответствии с принципами ООП.

## 2. Что такое объектно‑ориентированное программирование (ООП)

Объектно‑ориентированное программирование — это парадигма программирования, основанная на представлении программы в виде совокупности объектов, которые взаимодействуют между собой.

Каждый объект:
- хранит состояние (поля);
- имеет поведение (методы).

**Основные принципы ООП:**
- Инкапсуляция;
- Наследование;
- Полиморфизм;
- Абстракция (будет подробнее позже).

## 3. Класс и объект

### Класс

Класс — это шаблон (описание), по которому создаются объекты.

```java
class Person {
    String name;
    int age;
}
```

### Объект

Объект — это конкретный экземпляр класса.

```java
Person p1 = new Person();
p1.name = "Анна";
p1.age = 20;
```

## 4. Конструкторы

### Что такое конструктор

Конструктор — это специальный метод, который вызывается автоматически при создании объекта.

**Особенности конструктора:**
- имя совпадает с именем класса;
- не имеет типа возвращаемого значения;
- используется для инициализации полей.

### Пример конструктора

```java
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

**Создание объекта:**

```java
Person p = new Person("Иван", 25);
```

### Ключевое слово `this`

`this` — ссылка на текущий объект.

**Используется:**
- для различия полей класса и параметров конструктора;
- для вызова других конструкторов.

```java
this.name = name;
```

### Перегрузка конструкторов

В одном классе может быть несколько конструкторов с разными параметрами.

```java
class Person {
    String name;
    int age;

    Person() {
        name = "Без имени";
        age = 0;
    }

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

## 5. Инкапсуляция

### Суть инкапсуляции

Инкапсуляция — это сокрытие внутренней реализации объекта и предоставление доступа к данным только через методы.

**Основная идея:** поля — закрыты, методы — открыты.

### Модификаторы доступа

| Модификатор | Доступ |
| --- | --- |
| `private` | Только внутри класса |
| `default` | В пределах пакета |
| `protected` | Пакет + наследники |
| `public` | Везде |

### Пример инкапсуляции

❌ **Плохо:**

```java
class Person {
    public int age;
}
```

✅ **Хорошо:**

```java
class Person {
    private int age;

    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        }
    }

    public int getAge() {
        return age;
    }
}
```

### Getter и Setter

- **Getter** — метод для получения значения поля;
- **Setter** — метод для изменения значения поля с проверкой.

```java
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}
```

## 6. Наследование

### Что такое наследование

Наследование — механизм, позволяющий создать новый класс на основе существующего.

- новый класс — потомок (`subclass`);
- базовый класс — родитель (`superclass`).

### Синтаксис наследования

```java
class Student extends Person {
    String group;
}
```

Теперь `Student`:
- имеет поля и методы `Person`;
- может добавлять свои.

### Пример

```java
class Person {
    protected String name;

    public void sayHello() {
        System.out.println("Привет, я человек");
    }
}

class Student extends Person {
    public void study() {
        System.out.println("Я учусь");
    }
}
```

## 7. Переопределение методов (`@Override`)

Потомок может изменить поведение метода родителя.

```java
class Student extends Person {

    @Override
    public void sayHello() {
        System.out.println("Привет, я студент");
    }
}
```

**Аннотация `@Override`:**
- помогает избежать ошибок;
- показывает, что метод переопределён.

## 8. Полиморфизм

### Что такое полиморфизм

Полиморфизм — способность объекта вести себя по‑разному в зависимости от его реального типа.

**Ключевая идея:**  
родительская ссылка → объект потомка.

### Пример полиморфизма

```java
Person p = new Student();
p.sayHello();
```

Будет вызван метод `Student`, а не `Person`.

### Зачем нужен полиморфизм
- упрощает код;
- позволяет писать универсальные методы;
- делает программу расширяемой.

## 9. Пример объектной модели задачи

### Задача

Есть сотрудники компании:
- обычный сотрудник;
- менеджер;
- разработчик.

### UML‑логика (текстовая)

```
Employee
├── Manager
└── Developer
```

### Пример кода

```java
class Employee {
    protected String name;

    public void work() {
        System.out.println("Сотрудник работает");
    }
}

class Manager extends Employee {
    @Override
    public void work() {
        System.out.println("Менеджер управляет");
    }
}

class Developer extends Employee {
    @Override
    public void work() {
        System.out.println("Разработчик пишет код");
    }
}
```

## 10. Пример логики

**Поведение программы:**
1. Создаётся массив сотрудников.
2. В массив добавляются объекты разных типов.
3. Для каждого сотрудника вызывается метод `work()`.
4. Вызывается соответствующая реализация метода.

## 11. Частые ошибки

- ❌ Открытые поля (`public int age`);
- ❌ Отсутствие конструкторов;
- ❌ Отсутствие инкапсуляции;
- ❌ Наследование «ради наследования»;
- ❌ Непонимание, какой метод вызывается при полиморфизме.

## 12. Вопросы на подумать (для защиты)

1. Зачем нужен конструктор?
2. Чем инкапсуляция отличается от просто `private`?
3. Можно ли переопределить `private` метод?
4. Что произойдёт, если убрать `@Override`?
5. Почему полиморфизм невозможен без наследования?
6. Чем объект отличается от класса?
7. Зачем использовать `protected`, а не `public`?
8. Что произойдёт, если метод не переопределён в потомке?
