# Лабораторная работа № 3  
«Объектно‑ориентированное программирование в Java»

## 1. Цель лабораторной работы

Изучить и закрепить на практике принципы объектно‑ориентированного программирования в Java:
- использование классов и объектов;
- работа с конструкторами;
- инкапсуляция данных;
- наследование;
- полиморфизм;
- организация программы из нескольких классов.

## 2. Краткая теория (что используется в работе)

В лабораторной работе используются следующие элементы Java:
- классы и объекты;
- поля и методы класса;
- модификаторы доступа `private`, `protected`, `public`;
- конструкторы и перегрузка конструкторов;
- ключевое слово `this`;
- ключевое слово `super`;
- наследование (`extends`);
- переопределение методов (`@Override`);
- массивы объектов;
- циклы `for` / `foreach`.

## 3. Общая постановка задачи

Необходимо разработать консольное Java‑приложение, моделирующее работу системы управления сотрудниками организации.

Программа должна быть реализована строго в объектно‑ориентированном стиле.

## 4. Структура программы (обязательно)

Программа должна содержать не менее 5 классов, связанных между собой логически.

**Обязательные классы:**
- `Employee` — базовый класс (сотрудник);
- `Manager` — менеджер (наследник `Employee`);
- `Developer` — разработчик (наследник `Employee`);
- `Company` — класс для управления сотрудниками;
- `Main` — точка входа в программу.

## 5. Описание классов и требований

### 5.1 Класс `Employee` (базовый)

**Поля** (`private` / `protected`):
- `String name` — имя сотрудника;
- `int age` — возраст;
- `double baseSalary` — базовая зарплата.

**Конструкторы:**
- конструктор с параметрами для инициализации всех полей.

**Методы:**
- `double calculateSalary()` — возвращает базовую зарплату;
- `String getInfo()` — возвращает строку с информацией о сотруднике.

### 5.2 Класс `Manager` (наследник `Employee`)

**Дополнительные поля:**
- `double bonus` — премия.

**Конструктор:**
- инициализирует все поля, включая поля родительского класса.

**Методы:**
- переопределить `calculateSalary()` (зарплата = базовая + премия);
- переопределить `getInfo()`.

### 5.3 Класс `Developer` (наследник `Employee`)

**Дополнительные поля:**
- `int overtimeHours` — количество переработанных часов.

**Конструктор:**
- инициализирует все поля.

**Методы:**
- переопределить `calculateSalary()` (зарплата = базовая + переработка × фиксированная ставка);
- переопределить `getInfo()`.

### 5.4 Класс `Company`

Класс предназначен для хранения и обработки сотрудников.

**Поля:**
- массив `Employee[] employees`;
- текущее количество сотрудников.

**Методы:**
- добавление сотрудника в массив;
- вывод информации обо всех сотрудниках;
- подсчёт общей зарплаты всех сотрудников;
- поиск сотрудника с максимальной зарплатой.

### 5.5 Класс `Main`

В классе `Main` необходимо:
- создать объект `Company`;
- создать не менее 5 сотрудников разных типов;
- добавить сотрудников в компанию;
- вывести информацию о сотрудниках;
- вывести расчёт зарплат;
- продемонстрировать работу полиморфизма.

## 6. Требования к реализации

**❗ Обязательные требования:**
- все поля должны быть `private` или `protected`;
- доступ к данным — только через методы;
- запрещено хранить всю логику в `main`;
- использовать наследование и переопределение методов;
- использовать массив базового типа (`Employee[]`);
- программа должна компилироваться и корректно работать.

## 7. Блок‑схемы (обязательно)

Необходимо построить блок‑схемы для:
- алгоритма расчёта общей зарплаты;
- алгоритма поиска сотрудника с максимальной зарплатой.

**Блок‑схемы допускается выполнять:**
- от руки (с фото);
- в draw.io;
- в любом графическом редакторе.

## 8. Требования к отчёту

Отчёт должен содержать:
- титульный лист;
- цель лабораторной работы;
- условие задания;
- описание структуры программы;
- исходный код программы (по классам);
- блок‑схемы алгоритмов;
- скриншоты работы программы;
- ответы на контрольные вопросы;
- вывод.

**Формат отчёта:** PDF / DOCX.

## 9. Контрольные вопросы (обязательны в отчёте)

1. Что такое инкапсуляция и зачем она нужна?
2. В чём разница между классом и объектом?
3. Что такое конструктор?
4. Зачем используется ключевое слово `super`?
5. Что такое наследование?
6. Что такое полиморфизм?
7. Как работает переопределение методов?
8. Почему массив объявляется как `Employee[]`, а не `Manager[]`?
9. Какие преимущества даёт ООП по сравнению с процедурным подходом?
