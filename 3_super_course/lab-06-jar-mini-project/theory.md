# Лабораторная работа №6

## Сборка Java-приложения в JAR и мини-проект GUI

---

## 1. Назначение лабораторной работы

На предыдущей лабораторной работе было разработано полноценное GUI-приложение на Java с использованием библиотеки Swing. Однако любое программное обеспечение имеет смысл только тогда, когда его можно **запустить, передать и использовать**.

Цель данной лабораторной работы — довести приложение до **завершённого продукта**:

* оформить проект корректно;
* собрать исполняемый JAR-файл;
* проверить его работу на другом компьютере;
* доработать приложение до уровня мини-проекта.

Эта лабораторная работа является **логическим завершением блока Java GUI**.

---

## 2. Что такое JAR

**JAR (Java ARchive)** — это архивный файл, содержащий:

* скомпилированные `.class` файлы;
* ресурсы (файлы, иконки, конфигурации);
* файл `MANIFEST.MF` с описанием приложения.

JAR позволяет:

* запускать Java-приложение двойным кликом;
* распространять программу как единый файл;
* использовать приложение без среды разработки.

---

## 3. Структура Java-проекта

Типичная структура проекта:

```
src/
 ├── main/
 │   ├── java/
 │   │   └── package/
 │   │       ├── Main.java
 │   │       ├── ui/
 │   │       ├── logic/
 │   │       └── model/
 │   └── resources/
 └── test/
```

### Рекомендации:

* `Main` — точка входа (`public static void main`);
* `ui` — классы интерфейса;
* `logic` — бизнес-логика;
* `model` — модели данных.

---

## 4. MANIFEST.MF

Файл `MANIFEST.MF` содержит метаинформацию о JAR-файле.

Минимальный пример:

```
Manifest-Version: 1.0
Main-Class: package.Main
```

> ❗ Имя класса указывается **полностью**, с пакетом.

---

## 5. Сборка JAR в IntelliJ IDEA

### Шаги:

1. `File → Project Structure → Artifacts`
2. `+ → JAR → From modules with dependencies`
3. Указать `Main class`
4. Выбрать тип `Extract to the target JAR`
5. `Build → Build Artifacts`

После сборки файл появится в папке `out/artifacts`.

---

## 6. Запуск JAR-файла

### Через командную строку:

```bash
java -jar app.jar
```

### Через двойной клик:

* должна быть установлена JRE/JDK;
* корректно указан `Main-Class`.

---

## 7. Типичные ошибки при сборке JAR

* не указан `Main-Class`;
* неверное имя пакета;
* отсутствие зависимостей;
* использование относительных путей к файлам;
* код зависит от IDE.

---

## 8. Подготовка приложения к распространению

Перед сборкой необходимо:

* проверить работу всех кнопок;
* проверить обработку ошибок;
* проверить сохранение данных;
* убрать лишние выводы в консоль;
* привести код в порядок.

---

## 9. Мини-проект: доведение приложения до продукта

В рамках данной лабораторной работы приложение **дорабатывается до мини-проекта**.

Мини-проект должен:

* решать конкретную задачу пользователя;
* иметь завершённый интерфейс;
* корректно работать после перезапуска;
* быть собран в JAR-файл.

---

## 10. Требования к мини-проекту

Мини-проект обязан включать:

* GUI (Swing);
* работу с коллекциями;
* обработку исключений;
* сохранение данных;
* корректную архитектуру;
* исполняемый JAR.

---

## 11. Пример логики запуска

```java
public class Main {
    public static void main(String[] args) {
        javax.swing.SwingUtilities.invokeLater(() -> {
            new MainWindow();
        });
    }
}
```

Использование `invokeLater` гарантирует корректную работу GUI.

---

## 12. Проверка работоспособности

Перед сдачей:

1. Запустить JAR через терминал
2. Перенести JAR на другой компьютер
3. Проверить сохранение данных
4. Убедиться, что приложение не падает

---

## 13. Связь с дальнейшим курсом

Навыки из этой лабораторной работы напрямую используются в:

* Android Studio;
* сборке APK;
* публикации приложений;
* командной разработке.

---

## 14. Вопросы для защиты

1. Что такое JAR?
2. Чем JAR отличается от `.class` файлов?
3. Что такое `MANIFEST.MF`?
4. Зачем указывать `Main-Class`?
5. Почему важно тестировать приложение вне IDE?
6. Какие проблемы могут возникнуть при распространении?

---

## 15. Итог

После выполнения лабораторной работы студент должен:

* уметь собирать JAR-файлы;
* запускать приложения вне IDE;
* доводить программу до законченного продукта;
* понимать жизненный цикл настольного приложения.
